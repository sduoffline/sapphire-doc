# 后端结构设计思考

本想用gin简单实现一个，但是实际实践中发现了一些问题和一直想尝试的内容，遂做一些记录，希望能够帮助到其他人。目前，遇到的问题和希望实践的内容如下：

- 实践DDD：DDD是我一直想要实践的内容，但是一直没有找到合适的项目。DDD 最有吸引力的地方是充血模型和对领域的划分，在`Java`生态中大量使用的贫血模型往往导致`Service`格外膨胀。
  > 在`DDD`架构下，或许我们可以实现对业务功能的充分复用和拆分。例如十分常见的用户、角色、权限功能，我们可以将他们拆分为不同的`Domain`，当新项目需要使用这些功能时，只需要引入对应的`Domain`即可。
- 实践 Clean Architecture：Clean Architecture 算是个比较新的概念，他与 DDD 还是有一些区别的。应该说，DDD 关注对业务功能的划分，而 Clean Architecture 关注实现层面上如何组织一个仓库的代码。在复杂的项目中，常常会引入`RDB`以外的许多组件，例如`Redis`、`MQ`、`Neo4j`、`MongoDB`、`Elastic Search`和其他五花八门的东西（例如本项目要使用的`ONNX Runtime`），Clean Architecture 可以帮助我们更好的组织这些代码。
  > 然而 Clean Architecture 读下来是一种很理论的设计，个人认为可以作为参考对一些`client`（例如`MQ`的`worker`）进行组织。
- 分离接口和业务：对于一个可能持续演进的项目，在使用DDD对业务进行拆分后，业务之间将会有很好的独立性和服用能力，在此基础上若是可以将 RPC（例如`http`和`gRPC`） 与业务进行拆分，或许能收获一个更加灵活的项目。
  > 或许，我们还可以进一步想象一下，设计一个专门的接入层叫做`adapter`，并提供`http`、`gRPC`、`WebSocket/SSE`、`CMD`、`SSR`等不同的“接口”。这样的话，当对项目复用时，也可以快速将一个“用户”功能从`http`接口迁移到`CMD`接口。
- 减少编码：使用`wire`、`go:embed`、`go:generate`等工具，减少编码量，提高代码质量。
- 高可读性：在`Java`的设计中，函数的调用其实很棘手，当一个函数的参数过多时，我们往往会将参数封装为一个对象提高可读性，然而这会导致大量的`DTO`对象。本项目也希望解决这个问题。
- 更高效直观的对象构建：在`Java`中，我们可以使用`Builder`模式来构建对象，这样可以避免构造函数参数过多的问题。本项目也希望实现一种保证参数完整、灵活、编码量少、易于测试的对象构建方式。
- 易于测试：对于多数项目来讲测试其实没有太大必要，但是本项目还是希望能保证该架构下的`Domain`和`api`两个层面都是易于测试的。
- 隔绝DB等外部实现：为了保证框架的灵活性，我还希望能够将`DB`、`MQ`、`KV NoSQL`等外部实现隔离开来，保证项目可以快速在不同中间件之间切换。
- **减少工具类**：在`Java`中往往会使用`RedisUtil`、`MongoUtil`等工具类，这其实导致工具类本身的功能不够清晰，在对应中间件有一个好用的`client`的情况下，或许将对应的代码直接写在`Domain`中会更好。
  > 这部分代码好像也不应该在`Domain`中，因为一些情况下这类中间件可能并不是必须的业务逻辑，因此设计一个单独的层进行处理才能保护好`Domain`的可移植性。然而，对于`Domain`和`adapter`之间的交互，有些情况（`http`）可能需要缓存等机制，有些情况（`cmd`）可能并不需要，此时设计一个必须的层又显得过于复杂。
- 了解 CQRS：CQRS 是一个比较有争议的概念，他的核心思想是将读写分离，这样可以更好的扩展系统。但是，CQRS 也有一些问题，例如数据一致性问题，这是一个非常复杂的问题。在实际项目中，我并没有使用 CQRS，但是我认为了解这个概念是非常有必要的。

## 使用条件

如果这个项目不适合实践以上想法就没有必要了，此处先考虑考虑项目本身与以上想法的适配性。需要讨论的内容在设计思想和业务场景方面：

- 是否要引入`DDD`：`DDD`是一个非常有吸引力的概念，但是在实际项目中，我们往往会遇到一些问题，例如`DDD`的领域划分、贫血模型到充血模型的转换。这个项目好就好在有很多“领域”内容，不是简单的`CRUD`。例如，在标注任务的分发场景下，我们需要进行大量的标注覆盖率、标注结果置信度、标注结果一致性等计算，这些计算都是业务逻辑，而不是简单的`CRUD`。
- 是否要引入`Clean Architecture`：`Clean Architecture`在这个项目中相性尚可，其实我认为整洁架构的引入是有必要的，通过整洁架构至少可以减少一些`Java`习惯的影响，并且对`Redis`等中间件的引入也有一定的帮助。

## 参考案例

## 基本思路

在设计的基本思路方面，目前考虑如下：

- 对象划分：参考`Java`模式和`DDD`的设计理念，个人认为需要三种对象：`Entity`、`Value Object`和`DTO`。`Entity`是一个持久化对象，`VO`是一个不可变对象，`DTO`是一个传输对象。在`Java`中，`Entity`和`VO`的区别在于`Entity`有一个`id`字段，而`VO`没有。在`Go`中，我们可以使用`struct`的嵌套来实现这个功能。对于领域内的逻辑，`VO`应当被设计为充血的模型，由`VO`自己实现一些逻辑，而不是将逻辑放在`Service`中。
- 业务分层：从数据经由接入层清洗到持久化层的各种操作，只需要两层：`Domain`和`Service`，`Service`负责对`Domain`进行组装，`Domain`负责实现业务逻辑。这里`Domain`下使用的就是`VO`，而`Service`仅负责组装`VO`之间的关系。
- 持久化与其他操作：持久化的操作应当与其他第三方一样被隔离开来，使用一个`infra`层进行处理。`infra`层应当提供一个`interface`，`Domain`层通过`interface`与`infra`层进行交互。这样，当我们需要更换`DB`时，只需要更换`infra`层的实现即可。这意味着，当一个`Domain`需要将自己同时持久化到`RDB`和`Redis`时，我们需要在`infra`层中实现两个`interface`，并在`Domain`中调用两个`interface`，但是`VO`中仅暴露出一个`Save`方法。
- 接入层：接入层应当提供`http`、`gRPC`、`WebSocket/SSE`、`CMD`、`SSR`等不同的“接口”，该层就命名为`adapter`。`adapter`层应当负责将`http`请求转换为`Domain`的调用，并将`Domain`的返回转换为`http`的返回。这样，当我们需要将一个“用户”功能从`http`接口迁移到`CMD`接口时，只需要修改`adapter`层即可。
- 依赖注入和初始化：`Go`中没有`Spring`这样的依赖注入框架，但是我们可以使用`wire`来实现依赖注入。`wire`是一个代码生成工具，可以根据我们的依赖关系生成对应的代码。在`wire`中，我们可以将`Domain`、`Service`、`infra`和`adapter`的初始化放在一起，这样可以保证初始化的顺序。
- 校验等中间件：在`adapter`层中，我们可以引入一些中间件，例如`gin`的`validator`，这样可以保证`Domain`中的数据是合法的。在`Domain`中，我们也可以引入一些中间件，例如`gorm`的`hook`，这样可以保证`Domain`中的数据是合法的。通过这种`AOP`的方式，发挥一些`Java`的余温。

别的暂时也想不到了，先这样吧。
